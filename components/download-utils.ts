export interface Color {
  rgb: string;
  hex: string;
  id?: number;
}

export const downloadColorsAsCSV = (userColors: Color[]) => {
  try {
    // Create CSV content
    const csvHeaders = ['Index', 'Hex Code', 'R', 'G', 'B', 'RGB'];
    const csvRows = userColors.map((color, index) => {
      const rgbValues = color.rgb.replace("rgb(", "").replace(")", "").split(",").map(v => parseInt(v.trim()));
      const [r, g, b] = rgbValues;
      return [
        index + 1,
        color.hex,
        r,
        g,
        b,
        color.rgb
      ];
    });
    
    const csvContent = [
      csvHeaders.join(','),
      ...csvRows.map(row => row.join(','))
    ].join('\n');
    
    // Create and download file
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);
    link.setAttribute('href', url);
    link.setAttribute('download', `my-generated-colors-${new Date().toISOString().split('T')[0]}.csv`);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    return true;
  } catch (error) {
    console.error('Failed to download colors:', error);
    return false;
  }
};

export const downloadColorsAsJSON = (userColors: Color[]) => {
  try {
    // Create JSON content with metadata
    const jsonData = {
      metadata: {
        total_colors: userColors.length,
        export_date: new Date().toISOString(),
        source: "The Color Project",
        website: "https://thecolorproject.world",
        note: "Colors generated by you in this session"
      },
      colors: userColors.map((color, index) => {
        const rgbValues = color.rgb.replace("rgb(", "").replace(")", "").split(",").map(v => parseInt(v.trim()));
        const [r, g, b] = rgbValues;
        return {
          index: index + 1,
          hex: color.hex,
          rgb: {
            r: r,
            g: g,
            b: b
          },
          rgb_string: color.rgb
        };
      })
    };
    
    const jsonContent = JSON.stringify(jsonData, null, 2);
    
    // Create and download file
    const blob = new Blob([jsonContent], { type: 'application/json;charset=utf-8;' });
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);
    link.setAttribute('href', url);
    link.setAttribute('download', `my-generated-colors-${new Date().toISOString().split('T')[0]}.json`);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    return true;
  } catch (error) {
    console.error('Failed to download colors:', error);
    return false;
  }
};

export const downloadColorsAsPalette = (userColors: Color[]) => {
  try {
    // Create simple palette format content
    const paletteContent = userColors.map((color, index) => {
      const rgbValues = color.rgb.replace("rgb(", "").replace(")", "").split(",").map(v => parseInt(v.trim()));
      const [r, g, b] = rgbValues;
      return `${index + 1}. ${color.hex} RGB(${r}, ${g}, ${b})`;
    }).join('\n');
    
    // Create and download file
    const blob = new Blob([paletteContent], { type: 'text/plain;charset=utf-8;' });
    const link = document.createElement('a');
    const url = URL.createObjectURL(blob);
    link.setAttribute('href', url);
    link.setAttribute('download', `my-generated-palette-${new Date().toISOString().split('T')[0]}.txt`);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    return true;
  } catch (error) {
    console.error('Failed to download colors:', error);
    return false;
  }
};

export const showDownloadOptions = (userColors: Color[]) => {
  if (userColors.length === 0) {
    alert('No colors to download. Generate some colors first!');
    return false;
  }

  const options = [
    { label: 'CSV Format', value: 'csv', description: 'Spreadsheet compatible format' },
    { label: 'JSON Format', value: 'json', description: 'Developer-friendly format with metadata' },
    { label: 'Palette Format', value: 'palette', description: 'Simple text format for design tools' }
  ];
  
  const choice = prompt(
    `Choose download format:\n\n${options.map((opt, i) => `${i + 1}. ${opt.label} - ${opt.description}`).join('\n')}\n\nEnter 1, 2, or 3:`
  );
  
  switch (choice) {
    case '1':
      return downloadColorsAsCSV(userColors);
    case '2':
      return downloadColorsAsJSON(userColors);
    case '3':
      return downloadColorsAsPalette(userColors);
    default:
      return false;
  }
};
